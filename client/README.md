# Cryptomoji Client

Building a web app as a client to a Sawtooth blockchain is not much different than building a web app for any server. You will create some React components that will display the data you _GET_ from a REST API. Users will fill out forms and you will take that information and _POST_ it. Of course, everything you _GET_ will be a base64 encoded binary file, and all of your _POSTs_ will be cryptographically signed transactions. But that's where the fun is!

## Contents

- [Getting Started](#getting-started)
- [Running Tests](#running-tests)
- [Client](#client)
    * [01 Signing](#01-signing)
    * [02 Encoding](#02-encoding)
    * [03 Transactions](#03-transactions)
    * [04 Addressing](#04-addressing)
    * [05 Requests](#05-requests)
        - [GET /api/state/{address}](#get-apistateaddress)
        - [GET /api/state?address={partial address}](#get-apistateaddresspartial-address)
        - [POST /api/batches](#post-apibatches)
    * [06 The User Interface](#06-the-user-interface)

## Getting Started

This component uses npm to manage dependencies, so the first thing you should
do is install them:

```bash
cd code/part-two/client/
npm install
```

Once that's done, you will need to build your front-end code with _webpack_.
This will use [source/index.jsx](source/index.jsx) as an entry point, and pull
in all of your other modules from there to create a _bundle_ saved at
`public/bundle.js`. Anything in the [public/](public/) directory will be served
at `localhost:3000`, so when you run `docker-compose up`, you should be able to view 
it from your browser. In order to run the build, there are a few commands you can use.

You can build the production code:

```bash
npm run build:prod
```

However, most of the time you will probably what to build your code in
dev-mode. It builds faster, includes more debugging information, and will even
automatically rebuild every time you save changes:

```bash
npm run build:dev
```

And you can go a step further and serve the dev code from a live-reload server
at `localhost:3001`. Good news, you won't have to refresh your page! Bad news,
you won't be able to make any API calls or interact with the blockchain at all:

```bash
npm run watch
```

## Running Tests

Like other components, the front-end uses Mocha/Chai for testing. Unlike other
components, there is a pretty sweet browser-based test runner. To pull it up,
simply run:

```bash
npm test
```

## Client

### 01 Signing

**Module:** [source/services/signing.js](source/services/signing.js)

Sawtooth use Secp256k1 for signing. 

**Useful APIs:**
  - [secp256k1-node](https://github.com/cryptocoinjs/secp256k1-node#usage)
  - [Buffer.from](https://nodejs.org/api/buffer.html#buffer_class_method_buffer_from_string_encoding)
  - [Buffer.toString](https://nodejs.org/api/buffer.html#buffer_buf_tostring_encoding_start_end)

Signatures form the basis for verifiable identity and correctness on most, if
not all, blockchains. First, a _private key_ is generated; it's basically just
a random set of bytes. This key is kept secret. Next, a cryptographic algorithm
uses these bytes to derive a _public key_ which can be widely shared. Finally,
a _signature_ is generated by combining the private key with some message. This
signature, the message, and the public key are then all distributed together.

```
private key             message    private key
    |                         \     /
    v                          v   v
public key                   signature
```

While others won't ever be able to deduce the original private key, they will be
able to confirm that the public key and signature came from the _same_ private
key and that the message was not altered. Not even a single byte. This
powerful cryptographic tool is fundamental to how blockchains work.

```
public key -
             \
 signature - - - > ???
             /
   message -
```

A simple signing API is built using Secp256k1, a common
cryptographic algorithm used by Bitcoin, Ethereum, and Hyperledger Sawtooth.
It will be relying on the library [secp256k1-node](https://github.com/cryptocoinjs/secp256k1-node).

Note that this library uses [Node Buffers](https://nodejs.org/api/buffer.html)
(basically raw bytes) as the format of choice for keys and signatures. One of
the things to do is to convert these bytes to and from hex strings.
Make sure you are familiar with Buffer's `from` and `toString` methods.

### 02 Encoding

**Module:** [source/services/encoding.js](source/services/encoding.js)

Next, a module to encode/decode transactions and state
data is required. It will use _sorted_ JSON strings encoded in a Node Buffer. Webpack will allow you to use
Buffers in the browser just fine, but you could also use
[UInt8Arrays](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array)
if you prefer.

### 03 Transactions

**Module:** [source/services/transactions.js](source/services/transactions.js)

**Useful APIs:**
- [Ptotobuf.js](https://github.com/dcodeIO/ProtoBuf.js/#using-the-js-api)

This is the first really Sawtooth specific module. It is needed to take encoded 
payloads, and wrap them in a **transaction**. Then one or more transactions
get wrapped in a **batch**, and one or more batches get wrapped in a **batch list**,
which is finally serialized as bytes so it can be sent to the REST API. All of
these data structures are _Google Protobufs_, _very_ efficient in serializing data.

In particular, it is needed:

- `TransactionHeader.encode(headerData).finish()`
- `Transaction.create(transactionData)`
- `BatchHeader.encode(batchHeaderData).finish()`
- `Batch.create(batchData)`
- `BatchList.encode(batchListData).finish()`

### 04 Addressing

**Module:** [source/services/addressing.js](source/services/addressing.js)

Some stub functions to generate addresses for entities in state. 
They are needed in order to fetch any data from the REST API.

### 05 Requests

**Module:** [source/services/requests.js](source/services/requests.js)
**Useful APIs:**
- [Axios](https://github.com/axios/axios)
- [Sawtooth REST API](https://sawtooth.hyperledger.org/docs/core/releases/1.0/rest_api/endpoint_specs.html)

Sawtooth REST API has been proxied under the `api/` path, so you can access
every REST API route using a relative path. There are three routes/queries you
are likely to be concerned with.

#### GET /api/state/{address}

This fetches a base64 encoded entity from state. Sawtooth puts your data in a
JSON envelope under the `data` key, which axios automatically decodes for you,
and stores under the . . . `data` key. This means the data you want will be
in `response.data.data`.

#### GET /api/state?address={partial address}

The merkle tree that Sawtooth data is stored in allows you to fetch multiple
entities at once if they are under the same address _prefix_. So for example,
you could fetch `/api/state?address=5f4d76` to get every entity in state, or
`/api/state?address=5f4d7600` to get every collection. These entities will be
in a JSON array with this format:

```json
[
    {
        "address": "<string, full address>",
        "data": "<base64 string, encoded entity>"
    }
]
```

And yes, that means the base64 string you want to decode is at
`response.data.data[i].data`.

¯\\\_(ツ)\_/¯

#### POST /api/batches

This is the endpoint to which you will actually post your serialized batch
lists, included in the body of the request, and set the `Content-Type` 
header to `application/octet-stream`.

### 06 The User Interface

**Module:** [source/index.jsx](source/index.jsx)

The rest of the files are in source folder to:

- Allow users to generate new private keys and create collections
- Allow users to "sign in" by copying/pasting in their private key
- Allow users to View all cryptomoji in state
- Allow users to view just their own cryptomoji
- Allow users to select a sire from their collection
- Allow users to view all available sires
- Allow users to breed one of their cryptomoji with a sire

Note that a [parseDna](source/services/parse_dna.js#L190) method is provided,
which will convert a DNA string into a real _kaomoji_ for display. Make sure
you use it!
